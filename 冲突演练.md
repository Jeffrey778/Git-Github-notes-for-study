## :bulb:冲突演练：  
------
鉴于大家可能还不太熟练github与本地目录中的更新方法，及不同方法中的区别，为了方便大家的理解，我创建了一个“冲突演练.md”的文档，在这文档中，大家可以模拟工作冲突，熟练地去使用git pull，git push，git rebase，git fetch命令和他们之间的区别。方便大家学习，并且在解决冲突期间，我们遇到的问题将是类似的，也方便了大家讨论。  
文档的内容将在小组讨论后决定。  
项目分享与更新  
------
在 Git 中没有多少访问网络的命令，几乎所以的命令都是在操作本地的数据库。 当你想要分享你的工作，或者从其他地方拉取变更时，这有几个处理远程仓库的命令。  
* git fetch  
------
git fetch 命令与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后存储在你本地数据库中。我们开始在 从远程仓库中抓取与拉取 一节中介绍了此命令，然后我们在 远程分支 中看到了几个使用示例。我们在 向一个项目贡献 一节中有几个示例中也都有使用此命令。  
* git pull
-----
git pull 命令基本上就是 git fetch 和 git merge 命令的组合体，Git 从你指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。我们在 从远程仓库中抓取与拉取 一节中快速介绍了此命令，然后在 查看某个远程仓库 一节中了解了如果你运行此命令的话，什么将会合并。我们也在 用变基解决变基 一节中了解了如何使用此命令来来处理变基的难题。在 检出冲突 一节中我们展示了使用此命令如何通过一个 URL 来一次性的拉取变更。最后，我们在 签署提交 一节中我们快速的介绍了你可以使用 --verify-signatures 选项来验证你正在拉取下来的经过 GPG 签名的提交。

* git push
------
git push 命令用来与另一个仓库通信，计算你本地数据库与远程仓库的差异，然后将差异推送到另一个仓库中。 它需要有另一个仓库的写权限，因此这通常是需要验证的。

我们开始在 推送到远程仓库 一节中介绍了 git push 命令。 在这一节中主要介绍了推送一个分支到远程仓库的基本用法。 在 推送 一节中，我们深入了解了如何推送指定分支，在 跟踪分支 一节中我们了解了如何设置一个默认的推送的跟踪分支。 在 删除远程分支 一节中我们使用 --delete 标志和 git push 命令来在删除一个在服务器上的分支。

* git merge
-------
在许多介绍 Git 工作流的文章里，都会推荐在合并分支时，加上 --no-ff 参数：  
$ git checkout develop  
$ git merge --no-ff feature  
--no-ff 在这的作用是禁止快进式合并。   
Git 合并两个分支时，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，叫做“快进”（fast-forward），比如下图：    
          A---B---C feature  
         /  
D---E---F master  
要把 feature 合并到 master 中，执行以下命令  
$ git checkout master  
$ git merge feature   
结果就会变成  
          A---B---C feature  
         /         master  
D---E---F  
因为 feature 就在 master 的下游，所以直接移动了 master 的指针，master 和 feature 都指向了 C。而如果执行了 git merge --no-ff feature 的话，是下面的结果：  
          A---B---C feature  
         /         \  
D---E---F-----------G master     
由于 --no-ff 禁止了快进，所以会生成一个新的提交，master 指向 G。  
从合并后的代码来看，结果其实是一样的，区别就在于 --no-ff 会让 Git 生成一个新的提交对象。为什么要这样？通常我们把 master 作为主分支，上面存放的都是比较稳定的代码，提交频率也很低，而 feature 是用来开发特性的，上面会存在许多零碎的提交，快进式合并会把 feature 的提交历史混入到 master 中，搅乱 master 的提交历史。所以如果你根本不在意提交历史，也不爱管 master 干不干净，那么 --no-ff 其实没什么用。不过，如果某一次 master 出现了问题，你需要回退到上个版本的时候，比如上例，你就会发现退一个版本到了 B，而不是想要的 F，因为 feature 的历史合并进了 master 里。  





