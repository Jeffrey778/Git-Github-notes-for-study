Git补充知识
* ✦ git reset命令（撤销）  
1.问题场景：  
有时候，我们用commit提交代码后，发现这一次commit的内容是有错误的，那么有两种处理方法：  
1、修改错误内容，再次commit一次。  
2、使用gitreset命令撤销这一次错误的commit。  
第一种方法比较直接，但会多次一次commit记录。但错误的commit没必要保留下来。

* 2.命令描述：  
git-reset- Reset current HEAD to the specified state意思就是可以让HEAD这个指针指向其他的地方，例如我们有一次commit不是不是很满意，需要回到上一次的Commit里面。那么这个时候就需要通过reset，把HEAD指针指向上一次的commit的点。它有三种模式，soft,mixed,hard。  
* 3.举例说明：  
 1)reset --hard  
 场景：我在上次commit之后又对文件做了一些改动：把修改后的games.txt文件add到stage区，修改后的shoppinglist.txt保留在工作目录。  
 step1 敲入git status命令。  
 step2 执行了reset并附上了--hard参数gitreset--hardHEAD^
   
 2)reset --soft  
 场景：假设此时当前commit的改动内容是新增了laughter.txt文件，而commit后我又把修改后的games.txt文件add到stage区，修改后的shoppinglist.txt保留在工作目录。  
 step1 执行了reset并附上了--soft参数gitreset--softHEAD^，运行gitstatus可以看到，除了HEAD和它所指向的branch1被移动到HEAD^之外，原先HEAD处commit的改动（也就是那个laughters.txt文件）也会被   放进暂存区。
  
 3)reset不加参数(--mixed)  
 场景与第2种参数所处的场景相同。  
 step1 这时如果执行无参数的reset或者带--mixed参数。工作目录的内容和--soft一样会被保留，但和--soft的区别在于，它会把暂存区清空,并把原节点和reset节点的差异的文件放在工作目录，总而言之就是，   工作目录的修改、暂存区的内容以及由reset所导致的新的文件差异，都会被放进工作目录。
* 三种命令小结  
-------
区别：  
--hard：重置位置的同时，直接将workingTree工作目录、index暂存区及repository都重置成目标Reset节点的內容,所以效果看起来等同于清空暂存区和工作区。  

--soft：重置位置的同时，保留workingTree工作目录和index暂存区的内容，只让repository中的内容和reset目标节点保持一致，因此原节点和reset节点之间的【差异】会放入index暂存区中(Stagedfiles)。所以效果看起来就是工作目录的内容不变，暂存区原有的内容也不变，只是原节点和Reset节点之间的所有差异都会放到暂存区中。  

--mixed（默认）：重置位置的同时，只保留WorkingTree工作目录的內容，但会将Index暂存区和Repository中的內容更改和reset目标节点一致，因此原节点和Reset节点之间的【差异】会放入WorkingTree工作目录中。所以效果看起来就是原节点和Reset节点之间的所有差异都会放到工作目录中。  
